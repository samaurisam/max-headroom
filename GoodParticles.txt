// Avatar.jsx – 90-SECOND BREATH CYCLE
import { useEffect, useRef } from 'react';
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

export default function Avatar() {
  const mountRef = useRef(null);
  const particlesRef = useRef(null);
  const targetPositionsRef = useRef(null);
  const startPositionsRef = useRef(null);
  const offsetsRef = useRef(null);
  const isGatheringRef = useRef(true);
  const gatherStartTimeRef = useRef(0);
  const pulseStartTimeRef = useRef(0);

  useEffect(() => {
    // --- Scene ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0.8, 4.5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    mountRef.current.appendChild(renderer.domElement);

    // --- Lighting ---
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const light = new THREE.PointLight(0xffffff, 2, 15);
    light.position.set(0, 1.5, 4);
    scene.add(light);

    // --- GLTF Loader ---
    const loader = new GLTFLoader();
    loader.load(
      '/assets/max5.glb',
      (gltf) => {
        console.log('[Avatar] GLTF loaded – 90-second breath cycle...');

        // === FIND ALL MESHES ===
        const meshes = [];
        gltf.scene.traverse((child) => {
          if (child.isMesh) meshes.push(child);
        });

        if (meshes.length === 0) {
          console.error('No meshes found!');
          return;
        }

        // === SAMPLE FULL BODY ===
        const PARTICLE_COUNT = 20000;
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        const startPositions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const sizes = new Float32Array(PARTICLE_COUNT);
        const offsets = new Float32Array(PARTICLE_COUNT * 3);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
          const mesh = meshes[Math.floor(Math.random() * meshes.length)];
          const geom = mesh.geometry;
          const pos = geom.attributes.position.array;
          const idx = geom.index?.array;
          const faceCount = idx ? idx.length / 3 : pos.length / 9;

          const faceIdx = Math.floor(Math.random() * faceCount) * 3;
          const i0 = idx ? idx[faceIdx] : faceIdx;
          const i1 = idx ? idx[faceIdx + 1] : faceIdx + 1;
          const i2 = idx ? idx[faceIdx + 2] : faceIdx + 2;

          const v0 = new THREE.Vector3(pos[i0 * 3], pos[i0 * 3 + 1], pos[i0 * 3 + 2]);
          const v1 = new THREE.Vector3(pos[i1 * 3], pos[i1 * 3 + 1], pos[i1 * 3 + 2]);
          const v2 = new THREE.Vector3(pos[i2 * 3], pos[i2 * 3 + 1], pos[i2 * 3 + 2]);

          const r1 = Math.random(), r2 = Math.random();
          const sqrtR1 = Math.sqrt(r1);
          const a = 1 - sqrtR1, b = sqrtR1 * (1 - r2), c = sqrtR1 * r2;

          const localPos = new THREE.Vector3()
            .addScaledVector(v0, a)
            .addScaledVector(v1, b)
            .addScaledVector(v2, c);

          const worldPos = localPos.clone().applyMatrix4(mesh.matrixWorld);

          // TARGET: Loose final position
          const looseness = 0;
          targetPositions[i * 3] = worldPos.x + (Math.random() - 0.5) * looseness;
          targetPositions[i * 3 + 1] = worldPos.y + (Math.random() - 0.5) * looseness;
          targetPositions[i * 3 + 2] = worldPos.z + (Math.random() - 0.5) * looseness;

          // START: Dispersed cloud
          const angle = Math.random() * Math.PI * 2;
          const height = (Math.random() - 0.5) * 6;
          const radius = 4 + Math.random() * 4;
          startPositions[i * 3] = Math.cos(angle) * radius;
          startPositions[i * 3 + 1] = height;
          startPositions[i * 3 + 2] = Math.sin(angle) * radius;

          // RANDOM RGB COLORS
          colors[i * 3] = Math.random();
          colors[i * 3 + 1] = Math.random();
          colors[i * 3 + 2] = Math.random();

          sizes[i] = 0.8 + Math.random() * 0.6;

          offsets[i * 3] = Math.random() * Math.PI * 2;
          offsets[i * 3 + 1] = Math.random() * Math.PI * 2;
          offsets[i * 3 + 2] = Math.random() * Math.PI * 2;
        }

        targetPositionsRef.current = targetPositions;
        startPositionsRef.current = startPositions;
        offsetsRef.current = offsets;

        // === PARTICLE SYSTEM ===
        const particleGeometry = new THREE.BufferGeometry();
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(startPositions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 3));

        const particleMaterial = new THREE.PointsMaterial({
          size: 0.015,
          vertexColors: true,
          transparent: true,
          opacity: 0.9,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
        });

        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);
        particlesRef.current = particles;

        // === ANIMATION: 90-SECOND BREATH CYCLE ===
        const clock = new THREE.Clock();
        gatherStartTimeRef.current = clock.getElapsedTime();
        pulseStartTimeRef.current = gatherStartTimeRef.current;

        const gatherDuration = 30;     // First gather
        const pulseDuration = 30;     // ONE FULL CYCLE = 90 SECONDS

        const animate = () => {
          const now = clock.getElapsedTime();
          const pos = particleGeometry.attributes.position;
          const start = startPositionsRef.current;
          const target = targetPositionsRef.current;
          const offsets = offsetsRef.current;

          let t = 0;

          // PHASE 1: GATHER
          if (isGatheringRef.current) {
            const elapsed = now - gatherStartTimeRef.current;
            if (elapsed < gatherDuration) {
              t = elapsed / gatherDuration;
            } else {
              isGatheringRef.current = false;
              pulseStartTimeRef.current = now;
              t = 1;
            }
          }
          // PHASE 2: ULTRA-SLOW BREATHING
          else {
            const pulseElapsed = now - pulseStartTimeRef.current;
            const cycleT = (pulseElapsed % pulseDuration) / pulseDuration;
            t = 0.5 + Math.sin(cycleT * Math.PI * 2) * 0.5; // 0 → 1 → 0 over 90s
          }

          for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            const ox = offsets[i3], oy = offsets[i3 + 1], oz = offsets[i3 + 2];

            const tx = THREE.MathUtils.lerp(start[i3], target[i3], t);
            const ty = THREE.MathUtils.lerp(start[i3 + 1], target[i3 + 1], t);
            const tz = THREE.MathUtils.lerp(start[i3 + 2], target[i3 + 2], t);

            pos.array[i3] = tx + Math.sin(now * 1.2 + ox) * 0.04;
            pos.array[i3 + 1] = ty + Math.sin(now * 1.5 + oy) * 0.04;
            pos.array[i3 + 2] = tz + Math.sin(now * 1.3 + oz) * 0.04;

            sizes[i] = 0.8 + Math.sin(now * 3 + i * 0.01) * 0.4;
          }

          pos.needsUpdate = true;
          particleGeometry.attributes.size.needsUpdate = true;

          particles.rotation.y = now * 0.03;

          renderer.render(scene, camera);
          requestAnimationFrame(animate);
        };
        animate();
      },
      undefined,
      (err) => console.error('GLTF load error:', err)
    );

    // Resize
    const handleResize = () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    };
    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
      if (mountRef.current && renderer.domElement) {
        mountRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
    };
  }, []);

  return <div ref={mountRef} style={{ width: '100vw', height: '100vh', background: '#000' }} />;
}